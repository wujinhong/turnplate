package gordon.view.manage{	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundLoaderContext;	import flash.media.SoundTransform;	import flash.net.URLRequest;	import flash.utils.Dictionary;	import flash.utils.getQualifiedClassName;
	/**	 * SoundManager 用于管理声音和音乐，可以分类加载声音。对声音进行各种基本操作。 	 * @author David-Cai	 */	public class SoundManager	{//- PRIVATE & PROTECTED VARIABLES -------------------------------------------------------------------------		// singleton instance		private static var _instance:SoundManager;		private static var _allowInstance:Boolean;//		private var _mute:Boolean = false;		private var _soundsDict:Dictionary;		private var _sounds:Array;		private var _asset_manager:AssetManager=AssetManager.getInstance() as AssetManager;		private var _categories:Array=[];		private var _mute_categories:Array=[];		private var _sound_asset_linkages:Array;//- PUBLIC & INTERNAL VARIABLES ---------------------------------------------------------------------------//- CONSTRUCTOR	-------------------------------------------------------------------------------------------		// singleton instance of SoundManager		/**		 *		 * @return		 */		public static function getInstance():SoundManager		{			if (SoundManager._instance == null)			{				SoundManager._allowInstance=true;				SoundManager._instance=new SoundManager();				SoundManager._allowInstance=false;			}			return SoundManager._instance;		}		/**		 *		 * @throws Error		 */		public function SoundManager()		{			this._soundsDict =new Dictionary(true);			this._sound_asset_linkages = [];			this._sounds=new Array();			if (!SoundManager._allowInstance)			{				throw new Error("Error: Use SoundManager.getInstance() instead of the new keyword.");			}		}//- PRIVATE & PROTECTED METHODS ---------------------------------------------------------------------------//- PUBLIC & INTERNAL METHODS -----------------------------------------------------------------------------		/**		 * 注册声音的资源物件		 * 记录link_name的声音在哪个路径里面		 **/ 		public function register_assetObj(link_name:String,assetObj:AssetObj):void		{			if (!_sound_asset_linkages[link_name])			{								_sound_asset_linkages[link_name] = assetObj;			}			else			{				throw new Error('声音资源注册重复');			}		}		/***		 * 判断AssetManager里面是否有声音		 * linkname 连接名		 ***/ 		private function hasSound(linkname:String):Boolean		{			//先判断_sounds里面是否有声音			for each (var sound_name:String in _sounds)			{				if (sound_name == linkname)				{					return true;				}			}			return false;		}				/**		 * 添加声音到library		 * return 是否已经加载过这个声音		 */		public function addLibrarySound(linkname:String,auto_load:Boolean = false):Boolean		{			//没有播放过这个声音			if (!this.hasSound(linkname))			{				var sound_asset_class:Class=_asset_manager.GetAsset(linkname)				//该地址尚未加载				if (!sound_asset_class)				{					//如果需要自动加载声音					if (auto_load)					{						//开始加载声音						if (_sound_asset_linkages[linkname])						{							var game:Game = Game.getInstance();							if (!_asset_manager.has_asset(_sound_asset_linkages[linkname]) && !_asset_manager.has_loading_asset(_sound_asset_linkages[linkname]))							{								trace('加载声音'+_sound_asset_linkages[linkname].path+'========================');								_asset_manager.addNewAsset(_sound_asset_linkages[linkname],null,false);								return false;							}						}						else						{							throw new Error('没有找到声音资源');						}					}					return false;				}				else				{					if (_soundsDict[linkname]==null)					{						trace('添加声音到音乐库');						//已经加载过了，AssetManager 里面有这个资源，但是没有添加到库里面						//添加到声音库						var sndObj:Object=new Object();						var snd:Sound=new sound_asset_class();												sndObj.name=linkname;						sndObj.sound=snd;						sndObj.channel=new SoundChannel();						sndObj.position=0;						sndObj.paused=true;						sndObj.volume=1;						sndObj.startTime=0;						sndObj.loops=0;						sndObj.pausedByAll=false;												this._soundsDict[linkname]=sndObj;						this._sounds.push(sndObj);						return true;					}					else					{						return true;					}				}			}			return false;		}//		private function soundDownloaded():void//		{//			//		}		/**		 * Adds an external sound to the sounds dictionary for playing in the future.		 *		 * @param $path A string representing the path where the sound is on the server		 * @param $name The string identifier of the sound to be used when calling other methods on the sound		 * @param $buffer The number, in milliseconds, to buffer the sound before you can play it (default: 1000)		 * @param $checkPolicyFile A boolean that determines whether Flash Player should try to download a cross-domain policy file from the loaded sound's server before beginning to load the sound (default: false)		 *		 * @return Boolean A boolean value representing if the sound was added successfully		 */		public function addExternalSound($path:String, $name:String, $buffer:Number=1000, $checkPolicyFile:Boolean=false):Boolean		{			for (var i:int=0; i < this._sounds.length; i++)			{				if (this._sounds[i].name == $name)					return false;			}			var sndObj:Object=new Object();			var snd:Sound=new Sound(new URLRequest($path), new SoundLoaderContext($buffer, $checkPolicyFile));			sndObj.name=$name;			sndObj.sound=snd;			sndObj.channel=new SoundChannel();			sndObj.position=0;			sndObj.paused=true;			sndObj.volume=1;			sndObj.startTime=0;			sndObj.loops=0;			sndObj.pausedByAll=false;			sndObj.category='';			this._soundsDict[$name]=sndObj;			this._sounds.push(sndObj);			return true;		}		/**		 * Removes a sound from the sound dictionary.  After calling this, the sound will not be available until it is re-added.		 *		 * @param $name The string identifier of the sound to remove		 *		 * @return void		 */		public function removeSound($name:String):void		{			for (var i:int=0; i < this._sounds.length; i++)			{				if (this._sounds[i].name == $name)				{					this._sounds[i]=null;					this._sounds.splice(i, 1);				}			}			delete this._soundsDict[$name];		}		/**		 * Removes all sounds from the sound dictionary.		 *		 * @return void		 */		public function removeAllSounds():void		{			for (var i:int=0; i < this._sounds.length; i++)			{				this._sounds[i]=null;			}			this._sounds=new Array();			this._soundsDict=new Dictionary(true);		}		/**		 * Plays or resumes a sound from the sound dictionary with the specified name.		 *		 * @param $name The string identifier of the sound to play		 * @param $volume A number from 0 to 1 representing the volume at which to play the sound (default: 1)		 * @param $startTime A number (in milliseconds) representing the time to start playing the sound at (default: 0)		 * @param $loops An integer representing the number of times to loop the sound (default: 0)		 *		 * @return void		 */		public function playSound($name:String, $volume:Number=0.5, $startTime:Number=0, $loops:int=0, $category:String=''):void		{			var snd:Object=this._soundsDict[$name];			if (_mute_categories.indexOf($category) != -1)			{				snd.volume=0;			}			else			{				snd.volume=$volume;			}			snd.startTime=$startTime;			snd.loops=$loops;			snd.category=$category;			if (_categories.indexOf($category) == -1)			{				_categories.push($category);			}			if (snd.paused)			{				snd.channel=snd.sound.play(snd.position, snd.loops, new SoundTransform(snd.volume));			}			else			{				snd.channel=snd.sound.play($startTime, snd.loops, new SoundTransform(snd.volume));			}			snd.paused=false;		}		/**		 * Stops the specified sound.		 *		 * @param $name The string identifier of the sound		 *		 * @return void		 */		public function stopSound($name:String):void		{			try			{				var snd:Object=this._soundsDict[$name];				if (snd)				{					if (snd.channel)					{						snd.paused=true;						snd.channel.stop();						snd.position=snd.channel.position;					}				}			}			catch (e:Error)			{			}		}		/**		 * Pauses the specified sound.		 *		 * @param $name The string identifier of the sound		 *		 * @return void		 */		public function pauseSound($name:String):void		{			try			{				var snd:Object=this._soundsDict[$name];				if (snd)				{					if (snd.channel)					{						snd.paused=true;						snd.position=snd.channel.position;						snd.channel.stop();					}				}			}			catch (e:Error)			{			}		}		/**		 * Plays all the sounds that are in the sound dictionary.		 *		 * @param $useCurrentlyPlayingOnly A boolean that only plays the sounds which were currently playing before a pauseAllSounds() or stopAllSounds() call (default: false)		 *		 * @return void		 */		public function playAllSounds($useCurrentlyPlayingOnly:Boolean=false):void		{			try			{				for (var i:int=0; i < this._sounds.length; i++)				{					var id:String=this._sounds[i].name;					if ($useCurrentlyPlayingOnly)					{						if (this._soundsDict[id].pausedByAll)						{							this._soundsDict[id].pausedByAll=false;							this.playSound(id);						}					}					else					{						this.playSound(id);					}				}			}			catch (e:Error)			{			}		}		/**		 * Stops all the sounds that are in the sound dictionary.		 *		 * @param $useCurrentlyPlayingOnly A boolean that only stops the sounds which are currently playing (default: true)		 *		 * @return void		 */		public function stopAllSounds($useCurrentlyPlayingOnly:Boolean=true):void		{			for (var i:int=0; i < this._sounds.length; i++)			{				var id:String=this._sounds[i].name;				if ($useCurrentlyPlayingOnly)				{					if (!this._soundsDict[id].paused)					{						this._soundsDict[id].pausedByAll=true;						this.stopSound(id);					}				}				else				{					this.stopSound(id);				}			}		}		/**		 * Pauses all the sounds that are in the sound dictionary.		 *		 * @param $useCurrentlyPlayingOnly A boolean that only pauses the sounds which are currently playing (default: true)		 *		 * @return void		 */		public function pauseAllSounds($useCurrentlyPlayingOnly:Boolean=true):void		{			try			{				for (var i:int=0; i < this._sounds.length; i++)				{					var id:String=this._sounds[i].name;					if ($useCurrentlyPlayingOnly)					{						if (!this._soundsDict[id].paused)						{							this._soundsDict[id].pausedByAll=true;							this.pauseSound(id);						}					}					else					{						this.pauseSound(id);					}				}			}			catch (e:Error)			{			}		}		/**		 * Fades the sound to the specified volume over the specified amount of time.		 *		 * @param $name The string identifier of the sound		 * @param $targVolume The target volume to fade to, between 0 and 1 (default: 0)		 * @param $fadeLength The time to fade over, in seconds (default: 1)		 *		 * @return void		 */		public function fadeSound($name:String, $targVolume:Number=0, $fadeLength:Number=1):void		{			var fadeChannel:SoundChannel=this._soundsDict[$name].channel;			TweenLite.to(fadeChannel, $fadeLength, {volume: $targVolume});		}		/**		 * Mutes the volume for all sounds in the sound dictionary.		 *		 * @return void		 */		public function muteSounds($category:String=''):void		{			try			{				if (_mute_categories.indexOf($category) == -1)				{					_mute_categories.push($category);				}				for (var i:int=0; i < this._sounds.length; i++)				{					var id:String=this._sounds[i].name;					if (this._sounds[i].category == $category)					{						this.setSoundVolume(id, 0);					}				}			}			catch (e:Error)			{			}		}		/**		 * Resets the volume to their original setting for all sounds in the sound dictionary.		 *		 * @return void		 */		public function unmuteSounds($category:String=''):void		{			try			{				if (_mute_categories.indexOf($category) != -1)				{					_mute_categories.splice(_mute_categories.indexOf($category), 1);				}				for (var i:int=0; i < this._sounds.length; i++)				{					var id:String=this._sounds[i].name;					if (this._sounds[i].category == $category)					{						var snd:Object=this._soundsDict[id];						var curTransform:SoundTransform=snd.channel.soundTransform;						curTransform.volume=snd.volume;						snd.channel.soundTransform=curTransform;					}				}			}			catch (e:Error)			{			}		}		/**		 * Sets the volume of the specified sound.		 *		 * @param $name The string identifier of the sound		 * @param $volume The volume, between 0 and 1, to set the sound to		 *		 * @return void		 */		public function setSoundVolume($name:String, $volume:Number):void		{			try			{				var snd:Object=this._soundsDict[$name];				var curTransform:SoundTransform=snd.channel.soundTransform;				curTransform.volume=$volume;				snd.channel.soundTransform=curTransform;			}			catch (e:Error)			{			}		}		/**		 * Gets the volume of the specified sound.		 *		 * @param $name The string identifier of the sound		 *		 * @return Number The current volume of the sound		 */		public function getSoundVolume($name:String):Number		{			return this._soundsDict[$name].channel.soundTransform.volume;		}		/**		 * Gets the position of the specified sound.		 *		 * @param $name The string identifier of the sound		 *		 * @return Number The current position of the sound, in milliseconds		 */		public function getSoundPosition($name:String):Number		{			return this._soundsDict[$name].channel.position;		}		/**		 * Gets the duration of the specified sound.		 *		 * @param $name The string identifier of the sound		 *		 * @return Number The length of the sound, in milliseconds		 */		public function getSoundDuration($name:String):Number		{			return this._soundsDict[$name].sound.length;		}		/**		 * Gets the sound object of the specified sound.		 *		 * @param $name The string identifier of the sound		 *		 * @return Sound The sound object		 */		public function getSoundObject($name:String):Sound		{			return this._soundsDict[$name].sound;		}		/**		 * Identifies if the sound is paused or not.		 *		 * @param $name The string identifier of the sound		 *		 * @return Boolean The boolean value of paused or not paused		 */		public function isSoundPaused($name:String):Boolean		{			return this._soundsDict[$name].paused;		}		/**		 * Identifies if the sound was paused or stopped by calling the stopAllSounds() or pauseAllSounds() methods.		 *		 * @param $name The string identifier of the sound		 *		 * @return Number The boolean value of pausedByAll or not pausedByAll		 */		public function isSoundPausedByAll($name:String):Boolean		{			return this._soundsDict[$name].pausedByAll;		}//- EVENT HANDLERS ----------------------------------------------------------------------------------------//- GETTERS & SETTERS -------------------------------------------------------------------------------------		/**		 *		 * @return		 */		public function get sounds():Array		{			return this._sounds;		}//- HELPERS -----------------------------------------------------------------------------------------------		/**		 *		 * @return		 */		public function toString():String		{			return getQualifiedClassName(this);		}//- END CLASS ---------------------------------------------------------------------------------------------	}}